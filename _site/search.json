[
  {
    "objectID": "vasicek.html",
    "href": "vasicek.html",
    "title": "The Vasicek Model",
    "section": "",
    "text": "The Vasicek model (1977) assumes the process evolves as an Ornstein-Uhlenbeck process with constant coefficients:\n\\[\ndr_t = \\kappa(\\theta - r_t)dt+\\sigma dW_t\n\\]\n\n\n\n\\(\\kappa\\): Speed of mean reversion.\n\\(\\theta\\): Long-term mean level of the interest rate.\n\\(\\sigma\\): Instantaneous volatility."
  },
  {
    "objectID": "vasicek.html#mathematical-formulation",
    "href": "vasicek.html#mathematical-formulation",
    "title": "The Vasicek Model",
    "section": "",
    "text": "The Vasicek model (1977) assumes the process evolves as an Ornstein-Uhlenbeck process with constant coefficients:\n\\[\ndr_t = \\kappa(\\theta - r_t)dt+\\sigma dW_t\n\\]\n\n\n\n\\(\\kappa\\): Speed of mean reversion.\n\\(\\theta\\): Long-term mean level of the interest rate.\n\\(\\sigma\\): Instantaneous volatility."
  },
  {
    "objectID": "vasicek.html#python-simulation",
    "href": "vasicek.html#python-simulation",
    "title": "The Vasicek Model",
    "section": "Python Simulation",
    "text": "Python Simulation\nWe simulate the path using the Euler-Maruyama discretization method.\n\n\nCode\nimport numpy as np \nimport matplotlib.pyplot as plt \n\n# 1. Set Parameters\nr0 = 0.05\ntheta = 0.08\nkappa = 0.5\nsigma = 0.03\nT =1.0\ndt = 0.005\nN = int(T / dt)\nnum_paths = 10\n\n# 2. Simulation Loop\nt = np.linspace(0, T, N+1)\nrates = np.zeros((N+1, num_paths))\nrates[0, :] = r0\n\nnp.random.seed(42)\n\nfor i in range(1, N+1):\n    dw = np.random.normal(size=num_paths)\n    dr = kappa * (theta - rates[i-1, :]) * dt + sigma * np.sqrt(dt) * dw\n    rates[i, :] = rates[i-1, :] + dr\n\n# 3. Visualization\nplt.figure(figsize=(10, 6))\nplt.plot(t, rates, lw=1.5, alpha=0.7)\nplt.axhline(theta, color='black', linestyle='--', label=f'Long Term Mean ($\\\\theta={theta}$)')\nplt.title(f'Vasicek Model Simulation ({num_paths} paths)')\nplt.xlabel('Time (Years)')\nplt.ylabel('Interest Rate ($r_t$)')\nplt.legend()\nplt.grid(True, alpha=0.3)\nplt.show()"
  },
  {
    "objectID": "interest_env/Lib/site-packages/pyzmq-27.1.0.dist-info/licenses/LICENSE.html",
    "href": "interest_env/Lib/site-packages/pyzmq-27.1.0.dist-info/licenses/LICENSE.html",
    "title": "QuantRates",
    "section": "",
    "text": "BSD 3-Clause License\nCopyright (c) 2009-2012, Brian Granger, Min Ragan-Kelley\nAll rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
  },
  {
    "objectID": "interest_env/Lib/site-packages/numpy-2.4.0.dist-info/licenses/numpy/random/src/sfc64/LICENSE.html",
    "href": "interest_env/Lib/site-packages/numpy-2.4.0.dist-info/licenses/numpy/random/src/sfc64/LICENSE.html",
    "title": "SFC64",
    "section": "",
    "text": "Adapted from a C++ implementation of Chris Doty-Humphrey’s SFC PRNG.\nhttps://gist.github.com/imneme/f1f7821f07cf76504a97f6537c818083\nCopyright (c) 2018 Melissa E. O’Neill\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  {
    "objectID": "interest_env/Lib/site-packages/numpy-2.4.0.dist-info/licenses/numpy/random/src/sfc64/LICENSE.html#the-mit-license",
    "href": "interest_env/Lib/site-packages/numpy-2.4.0.dist-info/licenses/numpy/random/src/sfc64/LICENSE.html#the-mit-license",
    "title": "SFC64",
    "section": "",
    "text": "Adapted from a C++ implementation of Chris Doty-Humphrey’s SFC PRNG.\nhttps://gist.github.com/imneme/f1f7821f07cf76504a97f6537c818083\nCopyright (c) 2018 Melissa E. O’Neill\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  {
    "objectID": "interest_env/Lib/site-packages/numpy-2.4.0.dist-info/licenses/numpy/random/src/pcg64/LICENSE.html",
    "href": "interest_env/Lib/site-packages/numpy-2.4.0.dist-info/licenses/numpy/random/src/pcg64/LICENSE.html",
    "title": "PCG64",
    "section": "",
    "text": "PCG Random Number Generation for C.\nCopyright 2014 Melissa O’Neill oneill@pcg-random.org\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  {
    "objectID": "interest_env/Lib/site-packages/numpy-2.4.0.dist-info/licenses/numpy/random/src/pcg64/LICENSE.html#the-mit-license",
    "href": "interest_env/Lib/site-packages/numpy-2.4.0.dist-info/licenses/numpy/random/src/pcg64/LICENSE.html#the-mit-license",
    "title": "PCG64",
    "section": "",
    "text": "PCG Random Number Generation for C.\nCopyright 2014 Melissa O’Neill oneill@pcg-random.org\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  {
    "objectID": "interest_env/Lib/site-packages/numpy-2.4.0.dist-info/licenses/numpy/random/src/distributions/LICENSE.html",
    "href": "interest_env/Lib/site-packages/numpy-2.4.0.dist-info/licenses/numpy/random/src/distributions/LICENSE.html",
    "title": "QuantRates",
    "section": "",
    "text": "Copyright (c) 2005-2017, NumPy Developers. All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the NumPy Developers nor the names of any contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
  },
  {
    "objectID": "interest_env/Lib/site-packages/numpy-2.4.0.dist-info/licenses/numpy/random/src/distributions/LICENSE.html#numpy",
    "href": "interest_env/Lib/site-packages/numpy-2.4.0.dist-info/licenses/numpy/random/src/distributions/LICENSE.html#numpy",
    "title": "QuantRates",
    "section": "",
    "text": "Copyright (c) 2005-2017, NumPy Developers. All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the NumPy Developers nor the names of any contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
  },
  {
    "objectID": "interest_env/Lib/site-packages/numpy-2.4.0.dist-info/licenses/numpy/random/src/distributions/LICENSE.html#julia",
    "href": "interest_env/Lib/site-packages/numpy-2.4.0.dist-info/licenses/numpy/random/src/distributions/LICENSE.html#julia",
    "title": "QuantRates",
    "section": "Julia",
    "text": "Julia\nThe ziggurat methods were derived from Julia.\nCopyright (c) 2009-2019: Jeff Bezanson, Stefan Karpinski, Viral B. Shah, and other contributors:\nhttps://github.com/JuliaLang/julia/contributors\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  {
    "objectID": "interest_env/Lib/site-packages/numpy-2.4.0.dist-info/licenses/numpy/fft/pocketfft/LICENSE.html",
    "href": "interest_env/Lib/site-packages/numpy-2.4.0.dist-info/licenses/numpy/fft/pocketfft/LICENSE.html",
    "title": "QuantRates",
    "section": "",
    "text": "Copyright (C) 2010-2018 Max-Planck-Society All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
  },
  {
    "objectID": "interest_env/Lib/site-packages/idna-3.11.dist-info/licenses/LICENSE.html",
    "href": "interest_env/Lib/site-packages/idna-3.11.dist-info/licenses/LICENSE.html",
    "title": "QuantRates",
    "section": "",
    "text": "BSD 3-Clause License\nCopyright (c) 2013-2025, Kim Davies and contributors. All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
  },
  {
    "objectID": "interest_env/Lib/site-packages/httpcore-1.0.9.dist-info/licenses/LICENSE.html",
    "href": "interest_env/Lib/site-packages/httpcore-1.0.9.dist-info/licenses/LICENSE.html",
    "title": "QuantRates",
    "section": "",
    "text": "Copyright © 2020, Encode OSS Ltd. All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Interest Rate Modeling",
    "section": "",
    "text": "Welcome to QuantRates. This project explores short-rate models used in quantitative finance to simulate the evolution of interest rates over time.\nUnderstanding the behavior of the instantaneous spot rate, \\(r_t\\), is crucial for pricing fixed-income derivatives, such ad bonds and swaptions.\n\n\nMost one-factor short-rate models follow a Stochastic Differential Equation (SDE) of the form:\n\\[\ndr_t = \\mu(r_t, t)dt + \\sigma(r_t, t)dW_t\n\\]\nWhere:\n\n\\(r_t\\): The instantaneous short rate.\n\\(\\mu(r_t, t)\\): The drift term (deterministic trend).\n\\(\\sigma(r_t, t)\\): The diffusion term (volatility).\n\\(W_t\\): A Standard Brownian Motion (Wiener Process).\n\n\n\n\n\nThe Vasicek Model: A model allowing for mean reversion, though it allows negative interest rates.\nThe CIR Model: An extension that precludes negative interest rates by scaling volatility with the square root of the rate."
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "Interest Rate Modeling",
    "section": "",
    "text": "Welcome to QuantRates. This project explores short-rate models used in quantitative finance to simulate the evolution of interest rates over time.\nUnderstanding the behavior of the instantaneous spot rate, \\(r_t\\), is crucial for pricing fixed-income derivatives, such ad bonds and swaptions.\n\n\nMost one-factor short-rate models follow a Stochastic Differential Equation (SDE) of the form:\n\\[\ndr_t = \\mu(r_t, t)dt + \\sigma(r_t, t)dW_t\n\\]\nWhere:\n\n\\(r_t\\): The instantaneous short rate.\n\\(\\mu(r_t, t)\\): The drift term (deterministic trend).\n\\(\\sigma(r_t, t)\\): The diffusion term (volatility).\n\\(W_t\\): A Standard Brownian Motion (Wiener Process).\n\n\n\n\n\nThe Vasicek Model: A model allowing for mean reversion, though it allows negative interest rates.\nThe CIR Model: An extension that precludes negative interest rates by scaling volatility with the square root of the rate."
  },
  {
    "objectID": "cir.html",
    "href": "cir.html",
    "title": "Cox-Ingersoll-Ross (CIR) Model",
    "section": "",
    "text": "The CIR model (1985) introduces a square-root term in the diffusion component to prevent negative interest rates:\n\\[\ndr_t = \\kappa(\\theta - r_t)dt + \\sigma \\sqrt{r_t} dW_t\n\\]\nThe Feller condition, \\(2\\kappa\\theta &gt; \\sigma^2\\), ensures that the rate remains strictly positive."
  },
  {
    "objectID": "cir.html#mathematical-formulation",
    "href": "cir.html#mathematical-formulation",
    "title": "Cox-Ingersoll-Ross (CIR) Model",
    "section": "",
    "text": "The CIR model (1985) introduces a square-root term in the diffusion component to prevent negative interest rates:\n\\[\ndr_t = \\kappa(\\theta - r_t)dt + \\sigma \\sqrt{r_t} dW_t\n\\]\nThe Feller condition, \\(2\\kappa\\theta &gt; \\sigma^2\\), ensures that the rate remains strictly positive."
  },
  {
    "objectID": "cir.html#python-simulation",
    "href": "cir.html#python-simulation",
    "title": "Cox-Ingersoll-Ross (CIR) Model",
    "section": "Python Simulation",
    "text": "Python Simulation\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 1. Set Parameters\nr0 = 0.05\ntheta = 0.08\nkappa = 0.6\nsigma = 0.15 # Higher sigma to test boundaries\nT = 10.0\ndt = 0.005\nN = int(T / dt)\nnum_paths = 5\n\n# 2. Simulation Loop\nt = np.linspace(0, T, N+1)\nrates = np.zeros((N+1, num_paths))\nrates[0, :] = r0\n\nnp.random.seed(101)\n\nfor i in range(1, N+1):\n    # Ensure the term under sqrt is non-negative\n    r_prev = np.maximum(rates[i-1, :], 0)\n    \n    dr = kappa * (theta - r_prev) * dt + \\\n         sigma * np.sqrt(r_prev) * np.sqrt(dt) * np.random.normal(size=num_paths)\n    \n    rates[i, :] = r_prev + dr\n\n# 3. Visualization\nplt.figure(figsize=(10, 6))\nplt.plot(t, rates, lw=1.5)\nplt.axhline(theta, color='r', linestyle='--', label='Theta')\nplt.title('CIR Model Simulation')\nplt.xlabel('Time (Years)')\nplt.ylabel('Interest Rate')\nplt.legend()\nplt.grid(True, alpha=0.3)\nplt.show()"
  },
  {
    "objectID": "interest_env/Lib/site-packages/httpx-0.28.1.dist-info/licenses/LICENSE.html",
    "href": "interest_env/Lib/site-packages/httpx-0.28.1.dist-info/licenses/LICENSE.html",
    "title": "QuantRates",
    "section": "",
    "text": "Copyright © 2019, Encode OSS Ltd. All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
  },
  {
    "objectID": "interest_env/Lib/site-packages/numpy/random/LICENSE.html",
    "href": "interest_env/Lib/site-packages/numpy/random/LICENSE.html",
    "title": "NCSA Open Source License",
    "section": "",
    "text": "This software is dual-licensed under the The University of Illinois/NCSA Open Source License (NCSA) and The 3-Clause BSD License\n\nNCSA Open Source License\nCopyright (c) 2019 Kevin Sheppard. All rights reserved.\nDeveloped by: Kevin Sheppard (kevin.sheppard@economics.ox.ac.uk, kevin.k.sheppard@gmail.com) http://www.kevinsheppard.com\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal with the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimers.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimers in the documentation and/or other materials provided with the distribution.\nNeither the names of Kevin Sheppard, nor the names of any contributors may be used to endorse or promote products derived from this Software without specific prior written permission.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE SOFTWARE.\n\n\n3-Clause BSD License\nCopyright (c) 2019 Kevin Sheppard. All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\nComponents\nMany parts of this module have been derived from original sources, often the algorithm’s designer. Component licenses are located with the component code."
  },
  {
    "objectID": "interest_env/Lib/site-packages/numpy-2.4.0.dist-info/licenses/numpy/random/LICENSE.html",
    "href": "interest_env/Lib/site-packages/numpy-2.4.0.dist-info/licenses/numpy/random/LICENSE.html",
    "title": "NCSA Open Source License",
    "section": "",
    "text": "This software is dual-licensed under the The University of Illinois/NCSA Open Source License (NCSA) and The 3-Clause BSD License\n\nNCSA Open Source License\nCopyright (c) 2019 Kevin Sheppard. All rights reserved.\nDeveloped by: Kevin Sheppard (kevin.sheppard@economics.ox.ac.uk, kevin.k.sheppard@gmail.com) http://www.kevinsheppard.com\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal with the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimers.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimers in the documentation and/or other materials provided with the distribution.\nNeither the names of Kevin Sheppard, nor the names of any contributors may be used to endorse or promote products derived from this Software without specific prior written permission.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE SOFTWARE.\n\n\n3-Clause BSD License\nCopyright (c) 2019 Kevin Sheppard. All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\nComponents\nMany parts of this module have been derived from original sources, often the algorithm’s designer. Component licenses are located with the component code."
  },
  {
    "objectID": "interest_env/Lib/site-packages/numpy-2.4.0.dist-info/licenses/numpy/random/src/mt19937/LICENSE.html",
    "href": "interest_env/Lib/site-packages/numpy-2.4.0.dist-info/licenses/numpy/random/src/mt19937/LICENSE.html",
    "title": "MT19937",
    "section": "",
    "text": "MT19937\nCopyright (c) 2003-2005, Jean-Sebastien Roy (js@jeannot.org)\nThe rk_random and rk_seed functions algorithms and the original design of the Mersenne Twister RNG:\nCopyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura, All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nThe names of its contributors may not be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nOriginal algorithm for the implementation of rk_interval function from Richard J. Wagner’s implementation of the Mersenne Twister RNG, optimised by Magnus Jonsson.\nConstants used in the rk_double implementation by Isaku Wada.\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  {
    "objectID": "interest_env/Lib/site-packages/numpy-2.4.0.dist-info/licenses/numpy/random/src/philox/LICENSE.html",
    "href": "interest_env/Lib/site-packages/numpy-2.4.0.dist-info/licenses/numpy/random/src/philox/LICENSE.html",
    "title": "PHILOX",
    "section": "",
    "text": "PHILOX\nCopyright 2010-2012, D. E. Shaw Research. All rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions, and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions, and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of D. E. Shaw Research nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
  },
  {
    "objectID": "interest_env/Lib/site-packages/numpy-2.4.0.dist-info/licenses/numpy/random/src/splitmix64/LICENSE.html",
    "href": "interest_env/Lib/site-packages/numpy-2.4.0.dist-info/licenses/numpy/random/src/splitmix64/LICENSE.html",
    "title": "SPLITMIX64",
    "section": "",
    "text": "SPLITMIX64\nWritten in 2015 by Sebastiano Vigna (vigna@acm.org)\nTo the extent possible under law, the author has dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\nSee http://creativecommons.org/publicdomain/zero/1.0/."
  },
  {
    "objectID": "interest_env/Lib/site-packages/pyparsing/ai/best_practices.html",
    "href": "interest_env/Lib/site-packages/pyparsing/ai/best_practices.html",
    "title": "QuantRates",
    "section": "",
    "text": "If not provided or if target language definition is ambiguous, ask for examples of valid strings to be parsed\nBefore developing the pyparsing expressions, define a Backus-Naur Form definition and save this in docs/grammar.md. Update this document as changes are made in the parser."
  },
  {
    "objectID": "interest_env/Lib/site-packages/pyparsing/ai/best_practices.html#planning",
    "href": "interest_env/Lib/site-packages/pyparsing/ai/best_practices.html#planning",
    "title": "QuantRates",
    "section": "",
    "text": "If not provided or if target language definition is ambiguous, ask for examples of valid strings to be parsed\nBefore developing the pyparsing expressions, define a Backus-Naur Form definition and save this in docs/grammar.md. Update this document as changes are made in the parser."
  },
  {
    "objectID": "interest_env/Lib/site-packages/pyparsing/ai/best_practices.html#implementing",
    "href": "interest_env/Lib/site-packages/pyparsing/ai/best_practices.html#implementing",
    "title": "QuantRates",
    "section": "Implementing",
    "text": "Implementing\n\nImport pyparsing using import pyparsing as pp, and use that for all pyparsing references.\n\nIf referencing names from pyparsing.common, follow the pyparsing import with “ppc = pp.common” and use ppc as the namespace to access pyparsing.common.\nIf referencing names from pyparsing.unicode, follow the pyparsing import with “ppu = pp.unicode” and use ppu as the namespace to access pyparsing.unicode.\n\nWhen writing parsers that contain recursive elements (using Forward() or infix_notation()), immediately enable packrat parsing for performance: pp.ParserElement.enable_packrat() (call this right after importing pyparsing). See https://pyparsing-docs.readthedocs.io/en/latest/HowToUsePyparsing.html.\n\nFor recursive grammars, define placeholders with pp.Forward() and assign later using the &lt;&lt;= operator; give Forwards meaningful names with set_name() to improve errors.\n\nUse PEP8 method and argument names in the pyparsing API (parse_string, not parseString).\nDo not include expressions for matching whitespace in the grammar. Pyparsing skips whitespace by default.\nFor line-oriented grammars where newlines are significant, set skippable whitespace to just spaces/tabs early: pp.ParserElement.set_default_whitespace_chars(\" \\t\"), and define NL = pp.LineEnd().suppress() to handle line ends explicitly.\nPrefer operator forms for readability: use +, |, ^, ~, etc., instead of explicit And/MatchFirst/Or/Not classes (see Usage notes in https://pyparsing-docs.readthedocs.io/en/latest/HowToUsePyparsing.html).\nUse set_name() on all major grammar elements to support railroad diagramming and better error/debug output.\nThe grammar should be independently testable, without pulling in separate modules for data structures, evaluation, or command execution.\nUse results names for robust access to parsed data fields; results names should be valid Python identifiers to support attribute-style access on returned ParseResults.\n\nResults names should take the place of numeric indexing into parsed results in most places.\nDefine results names using call format not set_results_name(), example: full_name = Word(alphas)(\"first_name\") + Word(alphas)(\"last_name\")\nIf adding results name to an expression that is contains one more sub-expressions with results names, the expression must be inclused in a Group.\n\nPrefer Keyword over Literal for reserved words to avoid partial matches (e.g., Keyword(\"for\") will not match the leading “for” in “format”).\n\nUse pp.CaselessKeyword/pp.CaselessLiteral when keywords should match regardless of case.\n\nWhen the full input must be consumed, call parse_string with parse_all=True.\nIf the grammar must handle comments, define an expression for them and use the ignore() method to skip them.\n\nPrefer built-ins like pp.cpp_style_comment and pp.python_style_comment for common comment syntaxes.\n\nUse pyparsing Group to organize sub-expressions. Groups are also important for preserving results names when a sub-expression is used in a OneOrMore or ZeroOrMore expression.\nSuppress punctuation tokens to keep results clean; a convenient pattern is LBRACK, RBRACK, LBRACE, RBRACE, COLON = pp.Suppress.using_each(\"[]{}:\").\nFor comma-separated sequences, prefer pp.DelimitedList(...); wrap with pp.Optional(...) to allow empty lists or objects where appropriate.\nFor helper sub-expressions used only to build larger expressions, consider set_name(None) to keep result dumps uncluttered.\nUse pyparsing Each() to define a list of elements that may occur in any order.\n\nThe ‘&’ operator is the operator form of Each and is often more readable when combining order-independent parts.\n\nUse parse actions to do parse-time conversion of data from strings to useful data types.\n\nUse objects defined in pyparsing.common for common types like integer, real — these already have their conversion parse actions defined.\nFor quoted strings, use pp.dbl_quoted_string().set_parse_action(pp.remove_quotes) to unquote automatically.\nMap reserved words to Python constants per this example for parsing “true” to auto-convert to a Python True: pp.Keyword(\"true\").set_parse_action(pp.replace_with(True)) (and similarly for false/null/etc.).\nWhen you want native Python containers from the parse, use pp.Group(..., aslist=True) for lists and pp.Dict(..., asdict=True) for dict-like data.\n\nUse “using_each” with a list of keywords to define keyword constants, instead of separate assignments.\nChoose the appropriate matching method:\n\nparse_string() parses from the start\nsearch_string() searches anywhere in the text\nscan_string() yields all matches with positions\ntransform_string() is a convenience wrapper around scan_string to apply filters or transforms defined in parse actions, to perform batch transforms or conversions of expressions within a larger body of text\n\nFor line suffixes or directives, combine lookahead and slicing helpers: pp.FollowedBy(...) with pp.rest_of_line; when reusing a base expression with a different parse action, call .copy() before applying the new action to avoid side effects.\nWhen defining a parser to be used in a REPL:\n\nadd pyparsing Tag() elements of the form Tag(\"command\", &lt;command-name&gt;) to each command definition to support model construction from parsed commands.\ndefine model classes using dataclasses, and use the “command” attribute in the parsed results to identify which model class to create. The model classes can then be used to construct the model from the ParseResults returned by parse_string(). Define the models in a separate parser_models.py file.\n\nIf defining the grammar as part of a Parser class, only the finished grammar needs to be implemented as an instance variable.\nParseResults support “in” testing for results names. Use “in” tests for the existence of results names, not hasattr().\nAvoid left recursion where possible. If you must support left-recursive grammars, enable it with pp.ParserElement.enable_left_recursion() and do not enable packrat at the same time (these modes are incompatible).\nUse pp.SkipTo as a skipping expression to skip over arbitrary content.\n\nFor example, pp.SkipTo(pp.LineEnd()) will skip over all content until the end of the line; add a stop_on argument to SkipTo to stop skipping when a particular string is matched.\nUse ... in place of simple SkipTo(expression)"
  },
  {
    "objectID": "interest_env/Lib/site-packages/pyparsing/ai/best_practices.html#testing",
    "href": "interest_env/Lib/site-packages/pyparsing/ai/best_practices.html#testing",
    "title": "QuantRates",
    "section": "Testing",
    "text": "Testing\n\nUse the pyparsing ParserElement.run_tests method to run mini validation tests.\n\nPass a single multiline string to run_tests to test the parser on multiple test input strings, each line is a separate test.\nYou can add comments starting with “#” within the string passed to run_tests to document the individual test cases.\nTo pass test input strings that span multiple lines, pass the test input strings as a list of strings.\nPass parse_all=True to run_tests to test that the entire input is consumed.\n\nWhen generating unit tests for the parser:\n\ngenerate tests that include presence and absence of optional elements\nuse the methods in the mixin class pyparsing.testing.TestParseResultsAsserts to easily define expression, test input string, and expected results\ndo not generate tests for invalid data"
  },
  {
    "objectID": "interest_env/Lib/site-packages/pyparsing/ai/best_practices.html#debugging",
    "href": "interest_env/Lib/site-packages/pyparsing/ai/best_practices.html#debugging",
    "title": "QuantRates",
    "section": "Debugging",
    "text": "Debugging\n\nIf troubleshooting parse actions, use pyparsing’s trace_parse_action decorator to echo arguments and return value\nDuring development, call pp.autoname_elements() to auto-assign names to unnamed expressions to improve dump() and error messages.\nSub-expressions can be tested in isolation using ParserElement.matches()\nWhen defined out of order, Literals can mistakenly match fragments: Literal(\"for\") will match the leading “for” in “format”. Can be corrected by using Keyword instead of Literal.\nDump the parsed results using ParseResults.dump(), ParseResults.pprint(), or repr(ParseResults)."
  },
  {
    "objectID": "interest_env/Lib/site-packages/soupsieve-2.8.1.dist-info/licenses/LICENSE.html",
    "href": "interest_env/Lib/site-packages/soupsieve-2.8.1.dist-info/licenses/LICENSE.html",
    "title": "QuantRates",
    "section": "",
    "text": "MIT License\nCopyright (c) 2018 - 2025 Isaac Muse isaacmuse@gmail.com\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "vasicek_model.html",
    "href": "vasicek_model.html",
    "title": "Valuation Bond Pricing using Vasicek Model",
    "section": "",
    "text": "The Vasicek model is a popular short-rate model used in financial mathematics to describe the evolution of interest rates. It is defined by the following stochastic differential equation (SDE): \\[dr_t = a(b - r_t)dt + \\sigma dW_t\n\\] where: - \\(r_t\\) is the short-term interest rate at time \\(t\\), - \\(a\\) is the speed of mean reversion, - \\(b\\) is the long-term mean level, - \\(\\sigma\\) is the volatility of the interest rate, - \\(W_t\\) is a standard Wiener process (Brownian motion).\n\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport seaborn as sns\nimport datetime\nfrom scipy.stats import linregress\nfrom scipy.stats import norm\nimport statsmodels.api as sm\n\n\n\n\n\n\n\nCode\nimport pandas_datareader.data as web\n\nstart_date = datetime.datetime(2020, 1, 1)\nend_date = datetime.datetime(2025, 12, 31)\n\ndf = web.DataReader('DTB3', 'fred', start_date, end_date)\n\n\n\n\nCode\n# data = web.DataReader('DGS1', 'fred', start_date, end_date)\n# data = data.dropna()\n# data.index = pd.to_datetime(data.index)\n# data.head()\n\n\n\n\nCode\nimport yfinance as yf\nsymbol = \"^TNX\"\nstart_date = \"2012-01-01\"\nend_date = \"2024-01-31\"\n\ndata = yf.download(symbol, start=start_date, end=end_date)\ndata = data['Close'].dropna()\n\nrate = data.values\n\nplt.figure(figsize=(12,4))\nplt.plot(data, label='10-Year Treasury Yield')\nplt.title('10-Year Treasury Yield Over Time')\nplt.xlabel('Date')\nplt.ylabel('Yield')\nplt.legend()\nplt.show()\n\n\n[*********************100%***********************]  1 of 1 completed\n\n\n\n\n\n\n\n\n\n\n\nCode\ndf = data.copy()\n\n\n\n\nCode\ndf.head()\n\n\n\n\n\n\n\n\nTicker\n^TNX\n\n\nDate\n\n\n\n\n\n2012-01-03\n1.960\n\n\n2012-01-04\n1.995\n\n\n2012-01-05\n1.993\n\n\n2012-01-06\n1.961\n\n\n2012-01-09\n1.960\n\n\n\n\n\n\n\n\n\nCode\ndf.info()\n\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nDatetimeIndex: 3037 entries, 2012-01-03 to 2024-01-30\nData columns (total 1 columns):\n #   Column  Non-Null Count  Dtype  \n---  ------  --------------  -----  \n 0   ^TNX    3037 non-null   float64\ndtypes: float64(1)\nmemory usage: 47.5 KB\n\n\n\n\nCode\ndf = df.dropna()\ndf.index = pd.to_datetime(df.index)\ndf.head()\n\n\n\n\n\n\n\n\nTicker\n^TNX\n\n\nDate\n\n\n\n\n\n2012-01-03\n1.960\n\n\n2012-01-04\n1.995\n\n\n2012-01-05\n1.993\n\n\n2012-01-06\n1.961\n\n\n2012-01-09\n1.960\n\n\n\n\n\n\n\n\n\nCode\nplt.figure(figsize=(12, 6))\nsns.lineplot(data=df, x=df.index, y='^TNX')\nplt.title('10-Year Treasury Yield')\nplt.xlabel('Date')\nplt.ylabel('Rate (%)')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nOLP Calibrtion Method:\nWe can calibrate the Vasicek model using standard Linear Regression (Ordinary Least Squares - OLS).\nThe dicrete Euler equation for the Vasicek model is given by: \\[r_{t+1}-r_t = a(b-r_t)\\Delta t + \\sigma \\sqrt{\\Delta t} \\epsilon_t \\]\nWe can rewrite it to look like a linear regression equation: $(Y=+ X + ) $\n\\[\\underbrace{r_{t+1}}_{Y} = \\underbrace{ab\\Delta t}_{\\alpha} + \\underbrace{(1 - a\\Delta t)}_{\\beta} \\underbrace{r_t}_{X} + \\underbrace{\\sigma \\sqrt{\\Delta t} \\epsilon_t}_{\\text{noise}} \\]\nWhere \\(\\epsilon_t\\) is a standard normal random variable.\nBy running a regression of the change in rate \\((Y)\\) against the current rate \\((X)\\), we find estimates for \\(\\alpha\\) and \\(\\beta\\).\n\nSpeed of Reversion \\((a)\\) : \\(a = \\dfrac{1 - \\beta}{\\Delta t}\\)\nLong-term Mean Level \\((b)\\) : \\(b = \\dfrac{\\alpha}{a \\Delta t}\\)\nVolatility \\((\\sigma)\\) : The standard deviation of the residuals from the regression gives us \\(\\sigma \\sqrt{\\Delta t}\\), so we can compute \\(\\sigma\\) as: $\n\n\n\nCode\ndef calibrate_vasicek(rates, dt=1/252):\n    \"\"\"\n    Calibrates a, b, sigma using OLS on discretized SDE:\n    r_{i+1} = a*b*dt + (1 - a*dt)*r_i + sigma*sqrt(dt)*eps\n    \"\"\"\n    y = rates.values[1:]\n    x = rates.values[:-1]\n    X = sm.add_constant(x)\n    \n    model = sm.OLS(y, X).fit()\n    alpha, beta = model.params\n    residuals_std = np.std(model.resid)\n    \n    # Extract parameters from regression coefficients\n    a = (1 - beta) / dt\n    b = alpha / (a * dt)\n    sigma = residuals_std / np.sqrt(dt)\n    \n    return a, b, sigma\n\n\n\n\nCode\nrates = df['^TNX'] / 100\na, b, sigma = calibrate_vasicek(rates,dt=1/252)\n\nprint(f\"Calibrated Vasicek parameters:\")\nprint(f\"a (speed of reversion): {a}\")\nprint(f\"b (long-term mean): {b}\")\nprint(f\"sigma (volatility): {sigma}\")\n\n\nCalibrated Vasicek parameters:\na (speed of reversion): 0.2911154424136324\nb (long-term mean): 0.028783115580092614\nsigma (volatility): 0.00816174293304405\n\n\n\n\nCode\n# Optional: Visualize the fit\nplt.figure(figsize=(12, 6))\nplt.plot(df.index, df['^TNX']/100, label='Historical Rates')\nplt.axhline(y=b, color='r', linestyle='--', label=f'Calibrated Mean (b={b:.1%})')\nplt.title(\"Historical Short Rates vs. Calibrated Long-Term Mean\")\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nTo simulate the short rate \\(r_t\\) using the Vasicek model, we can use the following discretized version of the SDE: \\[r_{t+\\Delta t} = r_t + a(b - r_t)\\Delta t + \\sigma \\sqrt{\\Delta t} Z_t\\]\nwhere \\(Z_t\\) is a standard normal random variable.\n\n\nCode\ndef simulate_vasicek_paths(r0, a, b, sigma, T, dt, n_paths):\n    n_steps = int(T / dt)\n    rates = np.zeros((n_steps + 1, n_paths))\n    rates[0] = r0\n    \n    for t in range(1, n_steps + 1):\n        # dz ~ N(0, sqrt(dt))\n        dz = np.random.normal(0, np.sqrt(dt), n_paths)\n        # dr = a(b - r)dt + sigma * dW\n        rates[t] = rates[t-1] + a * (b - rates[t-1]) * dt + sigma * dz\n        \n    return rates\n\n\n\n\nCode\n# Simulation parameters\nr0 = rates[-1]\nT = 1.0  # 1 year\ndt = 1/252  # daily steps\nn_paths = 1000  # number of simulated paths\n\nrates_sim = simulate_vasicek_paths(r0, a, b, sigma, T, dt, n_paths)\ntime_grid = np.linspace(0, T, int(T/dt) + 1)\n\nmean_rates = np.mean(rates_sim, axis=1)\nplt.figure(figsize=(10, 6))\nplt.plot(time_grid, rates_sim[:, :50], lw=1) \nplt.plot(time_grid, mean_rates, lw=2, color='blue')\nplt.title('Simulated Interest Rate Paths (Vasicek Model)')\nplt.xlabel('Time (years)')\nplt.ylabel('Interest Rate (%)')\nplt.axhline(y=b, color='r', linestyle='--', label='Long-term Mean (b)')\nplt.text(0.1, b - 0.003, f'b = {b:.4f}', color='r')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\nC:\\Users\\mengh\\AppData\\Local\\Temp\\ipykernel_2312\\3343935822.py:2: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  r0 = rates[-1]\n\n\n\n\n\n\n\n\n\n\n\n\nThe price of a zero-coupon bond in the Vasicek model can be calculated using the following formula: \\[P(t,T) = A(t,T) e^{-B(t,T) r_t}\\] where: - \\(P(t,T)\\) is the price of the bond at time \\(t\\) maturing at time \\(T\\), - \\(A(t,T)\\) and \\(B(t,T)\\) are functions defined as:\n\\[B(t,T) = \\dfrac{1 - e^{-a(T-t)}}{a}\\]\n\\[A(t,T) = \\exp\\left( \\left( b - \\dfrac{\\sigma^2}{2a^2} \\right) \\left( B(t,T) - (T-t) \\right) - \\dfrac{\\sigma^2 B(t,T)^2}{4a} \\right)\\]\n\n\nCode\ndef analytical_bond_price(r, a, b, sigma, T):\n    B = (1 - np.exp(-a * T)) / a\n    A = np.exp((B - T) * (a**2 * b - 0.5 * sigma**2) / a**2 - (sigma**2 * B**2) / (4 * a))\n    P = A * np.exp(-B * r)\n    return P\n\nT_bond = 1.0  # 1 year bond\nbond_prices = analytical_bond_price(r0, a, b, sigma, T_bond)\nprint(f\"Analytical price of a zero-coupon bond maturing in {T_bond} year(s): {bond_prices:.4f}\")\n\n\nAnalytical price of a zero-coupon bond maturing in 1.0 year(s): 0.9617\n\n\n\n\n\nTo estimate the price of a Zero-Coupon Bond (ZCB) using Monte Carlo simulation, we can follow these steps:\nThe price of a bond is the risk-neutral expectation of the discounted payoff:\n\\[P(0,T) = E^Q\\left[e^{-\\int_0^T r_t dt}\\right]\\]\nIn our simulation, the integral becomes a sum, and the expectation is approximated by the average over many simulated paths.\n\\[P_{MC} \\approx \\dfrac{1}{N} \\sum_{i=1}^{N}\\left( \\exp \\left(-\\sum_{j=0}^{M-1} r_{t_j}^{(i)} \\Delta t \\right)\\right)\\]\n\n\nCode\ndef price_bond_mc(rates, dt):\n    # Stochastic Discount Factor: exp(-integral of r_t dt)\n    integral_r = np.sum(rates[:-1, :], axis=0) * dt\n    payoffs = np.exp(-integral_r)\n    return np.mean(payoffs)\n\n# Price a 1-year bond\nT_target = 1.0\nsteps_target = int(T_target / dt)\nmc_price = price_bond_mc(rates_sim[:, :], dt)\nanalyt_price = analytical_bond_price(r0, a, b, sigma, T_target)\n\nprint(f\"--- Comparison  ---\")\nprint(f\"Analytical Price (1Y): {analyt_price:.5f}\")\nprint(f\"Monte Carlo Price (1Y): {mc_price:.5f}\")\nprint(f\"Error: {abs(mc_price - analyt_price):.5f}\")\n\n\n--- Comparison  ---\nAnalytical Price (1Y): 0.96173\nMonte Carlo Price (1Y): 0.96175\nError: 0.00001\n\n\n\n\n\n\n\nCode\n# Parameters\nT_max = 10\ndt = 1/252\n\n\nmaturities = np.arange(1,T_max+1)\nanalytical_prices = [analytical_bond_price(r0, a, b, sigma, T) for T in maturities]\n\n# Monte Carlo\nn_paths = 1000\nmc_prices = []\nfor T in maturities:\n    full_paths = simulate_vasicek_paths(r0, a, b, sigma, T, dt, n_paths)\n    integral_r = np.sum(full_paths, axis=0)*dt\n    mc_prices.append(np.mean(np.exp(-integral_r)))\n\nplt.figure(figsize=(10, 5))\nplt.plot(maturities, analytical_prices, 'o-', label='Analytical Price', markersize=8)\nplt.plot(maturities, mc_prices, 'x--', label=f'Monte Carlo Price (N={n_paths})', markersize=8)\nplt.title(\"Task 3: Analytical vs. Monte Carlo Bond Prices\")\nplt.xlabel(\"Maturity (Years)\")\nplt.ylabel(\"Price\")\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\nabsolute_errors = [abs(ap - mp) for ap, mp in zip(analytical_prices, mc_prices)]\n\ncomparison_df = pd.DataFrame({\n    'Maturity (Years)': maturities,\n    'Analytical Price': analytical_prices,\n    f'Monte Carlo Price (N={n_paths})': mc_prices,\n    'Absolute Error': absolute_errors\n})\n\ncomparison_df\n\n\n\n\n\n\n\n\n\nMaturity (Years)\nAnalytical Price\nMonte Carlo Price (N=1000)\nAbsolute Error\n\n\n\n\n0\n1\n0.961734\n0.961529\n0.000205\n\n\n1\n2\n0.927366\n0.927190\n0.000176\n\n\n2\n3\n0.896006\n0.895275\n0.000731\n\n\n3\n4\n0.867007\n0.865980\n0.001027\n\n\n4\n5\n0.839894\n0.839199\n0.000695\n\n\n5\n6\n0.814320\n0.814280\n0.000040\n\n\n6\n7\n0.790027\n0.790127\n0.000099\n\n\n7\n8\n0.766825\n0.769030\n0.002205\n\n\n8\n9\n0.744570\n0.743563\n0.001008\n\n\n9\n10\n0.723155\n0.719999\n0.003156\n\n\n\n\n\n\n\n\n\n\nUsing the analytical bond pricing formula, generate the yield curve for different maturities $ T $ by calculating the yield $ y(0,T) $: \\[ y(0,T) = -\\frac{1}{T} \\ln(P(0,T)) \\]\n\nAnalyze how changes in parameters $ a $, $ b $, and $ $ affect the shape of the yield curve.\n\n\n\nCode\nmaturities = np.linspace(0.1, 10, 100)\n\ndef get_yields(a, b, sigma):\n    prices = [analytical_bond_price(r0, a, b, sigma, T) for T in maturities]\n    return -np.log(prices) / maturities\n\n\n\n\nCode\nplt.figure(figsize=(12, 8))\nplt.plot(maturities, get_yields(a, b, sigma), label='Base Case', lw=2)\nplt.title(\"Base Yield Curve\")\nplt.xlabel(\"Maturity\")\nplt.ylabel(\"Yield\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\nplt.figure(figsize=(12, 5))\nplt.subplot(1, 2, 1)\n\na_imp = [a/2, a, a*2]\nfor a_val in a_imp:\n    yields = get_yields(a_val, b, sigma)\n    plt.plot(maturities, yields, label=f'a={a_val:.4f}')\nplt.title(\"Impact of Mean Reversion Speed (a)\")\nplt.xlabel(\"Maturity (Years)\")\nplt.ylabel(\"Yield\")\nplt.legend()\nplt.grid(True)\n\n# Scenario B: Effect of 'sigma' (Volatility)\nsigma_imp = [sigma/2, sigma, sigma*2]\nplt.subplot(1, 2, 2)\nfor sig_val in sigma_imp:\n    yields = get_yields(a, b, sig_val)\n    plt.plot(maturities, yields, label=f'sigma={sig_val:.4f}')\nplt.title(\"Impact of Volatility (sigma)\")\nplt.xlabel(\"Maturity (Years)\")\nplt.ylabel(\"Yield\")\nplt.legend()\nplt.grid(True)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Task 4: Yield Curve and Sensitivity\nm_yields = np.linspace(0.1, 30, 100)\ndef get_yields(a, b, sigma):\n    prices = [analytical_bond_price(r0, a, b, sigma, T) for T in m_yields]\n    return -np.log(prices) / m_yields\n\nplt.figure(figsize=(12, 8))\nplt.subplot(2, 2, 1)\nplt.plot(m_yields, get_yields(a, b, sigma), label='Base Case', lw=2)\nplt.title(\"Base Yield Curve\")\nplt.xlabel(\"Maturity\")\nplt.ylabel(\"Yield\")\nplt.grid(alpha=0.5)\n\nplt.subplot(2, 2, 2)\nplt.plot(m_yields, get_yields(a, b, sigma), label=f'a={a:.2f}')\nplt.plot(m_yields, get_yields(2*a, b, sigma), label=f'a={2*a:.2f}')\nplt.title(\"Sensitivity to Mean Reversion (a)\")\nplt.legend()\nplt.grid(alpha=0.5)\n\nplt.subplot(2, 2, 3)\nplt.plot(m_yields, get_yields(a, b, sigma), label=f'b={b:.2f}')\nplt.plot(m_yields, get_yields(a, 2*b, sigma), label=f'b={2*b:.2f}')\nplt.title(\"Sensitivity to Long-term Mean (b)\")\nplt.legend()\nplt.grid(alpha=0.5)\n\nplt.subplot(2, 2, 4)\nplt.plot(m_yields, get_yields(a, b, sigma), label=f'$\\sigma={sigma:.2f}$')\nplt.plot(m_yields, get_yields(a, b, 2*sigma), label=f'$\\sigma={2*sigma:.2f}$')\nplt.title(\"Sensitivity to Volatility ($\\sigma$)\")\nplt.legend()\nplt.grid(alpha=0.5)\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "vasicek_model.html#vasicek-model",
    "href": "vasicek_model.html#vasicek-model",
    "title": "Valuation Bond Pricing using Vasicek Model",
    "section": "",
    "text": "The Vasicek model is a popular short-rate model used in financial mathematics to describe the evolution of interest rates. It is defined by the following stochastic differential equation (SDE): \\[dr_t = a(b - r_t)dt + \\sigma dW_t\n\\] where: - \\(r_t\\) is the short-term interest rate at time \\(t\\), - \\(a\\) is the speed of mean reversion, - \\(b\\) is the long-term mean level, - \\(\\sigma\\) is the volatility of the interest rate, - \\(W_t\\) is a standard Wiener process (Brownian motion).\n\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport seaborn as sns\nimport datetime\nfrom scipy.stats import linregress\nfrom scipy.stats import norm\nimport statsmodels.api as sm\n\n\n\n\n\n\n\nCode\nimport pandas_datareader.data as web\n\nstart_date = datetime.datetime(2020, 1, 1)\nend_date = datetime.datetime(2025, 12, 31)\n\ndf = web.DataReader('DTB3', 'fred', start_date, end_date)\n\n\n\n\nCode\n# data = web.DataReader('DGS1', 'fred', start_date, end_date)\n# data = data.dropna()\n# data.index = pd.to_datetime(data.index)\n# data.head()\n\n\n\n\nCode\nimport yfinance as yf\nsymbol = \"^TNX\"\nstart_date = \"2012-01-01\"\nend_date = \"2024-01-31\"\n\ndata = yf.download(symbol, start=start_date, end=end_date)\ndata = data['Close'].dropna()\n\nrate = data.values\n\nplt.figure(figsize=(12,4))\nplt.plot(data, label='10-Year Treasury Yield')\nplt.title('10-Year Treasury Yield Over Time')\nplt.xlabel('Date')\nplt.ylabel('Yield')\nplt.legend()\nplt.show()\n\n\n[*********************100%***********************]  1 of 1 completed\n\n\n\n\n\n\n\n\n\n\n\nCode\ndf = data.copy()\n\n\n\n\nCode\ndf.head()\n\n\n\n\n\n\n\n\nTicker\n^TNX\n\n\nDate\n\n\n\n\n\n2012-01-03\n1.960\n\n\n2012-01-04\n1.995\n\n\n2012-01-05\n1.993\n\n\n2012-01-06\n1.961\n\n\n2012-01-09\n1.960\n\n\n\n\n\n\n\n\n\nCode\ndf.info()\n\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nDatetimeIndex: 3037 entries, 2012-01-03 to 2024-01-30\nData columns (total 1 columns):\n #   Column  Non-Null Count  Dtype  \n---  ------  --------------  -----  \n 0   ^TNX    3037 non-null   float64\ndtypes: float64(1)\nmemory usage: 47.5 KB\n\n\n\n\nCode\ndf = df.dropna()\ndf.index = pd.to_datetime(df.index)\ndf.head()\n\n\n\n\n\n\n\n\nTicker\n^TNX\n\n\nDate\n\n\n\n\n\n2012-01-03\n1.960\n\n\n2012-01-04\n1.995\n\n\n2012-01-05\n1.993\n\n\n2012-01-06\n1.961\n\n\n2012-01-09\n1.960\n\n\n\n\n\n\n\n\n\nCode\nplt.figure(figsize=(12, 6))\nsns.lineplot(data=df, x=df.index, y='^TNX')\nplt.title('10-Year Treasury Yield')\nplt.xlabel('Date')\nplt.ylabel('Rate (%)')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nOLP Calibrtion Method:\nWe can calibrate the Vasicek model using standard Linear Regression (Ordinary Least Squares - OLS).\nThe dicrete Euler equation for the Vasicek model is given by: \\[r_{t+1}-r_t = a(b-r_t)\\Delta t + \\sigma \\sqrt{\\Delta t} \\epsilon_t \\]\nWe can rewrite it to look like a linear regression equation: $(Y=+ X + ) $\n\\[\\underbrace{r_{t+1}}_{Y} = \\underbrace{ab\\Delta t}_{\\alpha} + \\underbrace{(1 - a\\Delta t)}_{\\beta} \\underbrace{r_t}_{X} + \\underbrace{\\sigma \\sqrt{\\Delta t} \\epsilon_t}_{\\text{noise}} \\]\nWhere \\(\\epsilon_t\\) is a standard normal random variable.\nBy running a regression of the change in rate \\((Y)\\) against the current rate \\((X)\\), we find estimates for \\(\\alpha\\) and \\(\\beta\\).\n\nSpeed of Reversion \\((a)\\) : \\(a = \\dfrac{1 - \\beta}{\\Delta t}\\)\nLong-term Mean Level \\((b)\\) : \\(b = \\dfrac{\\alpha}{a \\Delta t}\\)\nVolatility \\((\\sigma)\\) : The standard deviation of the residuals from the regression gives us \\(\\sigma \\sqrt{\\Delta t}\\), so we can compute \\(\\sigma\\) as: $\n\n\n\nCode\ndef calibrate_vasicek(rates, dt=1/252):\n    \"\"\"\n    Calibrates a, b, sigma using OLS on discretized SDE:\n    r_{i+1} = a*b*dt + (1 - a*dt)*r_i + sigma*sqrt(dt)*eps\n    \"\"\"\n    y = rates.values[1:]\n    x = rates.values[:-1]\n    X = sm.add_constant(x)\n    \n    model = sm.OLS(y, X).fit()\n    alpha, beta = model.params\n    residuals_std = np.std(model.resid)\n    \n    # Extract parameters from regression coefficients\n    a = (1 - beta) / dt\n    b = alpha / (a * dt)\n    sigma = residuals_std / np.sqrt(dt)\n    \n    return a, b, sigma\n\n\n\n\nCode\nrates = df['^TNX'] / 100\na, b, sigma = calibrate_vasicek(rates,dt=1/252)\n\nprint(f\"Calibrated Vasicek parameters:\")\nprint(f\"a (speed of reversion): {a}\")\nprint(f\"b (long-term mean): {b}\")\nprint(f\"sigma (volatility): {sigma}\")\n\n\nCalibrated Vasicek parameters:\na (speed of reversion): 0.2911154424136324\nb (long-term mean): 0.028783115580092614\nsigma (volatility): 0.00816174293304405\n\n\n\n\nCode\n# Optional: Visualize the fit\nplt.figure(figsize=(12, 6))\nplt.plot(df.index, df['^TNX']/100, label='Historical Rates')\nplt.axhline(y=b, color='r', linestyle='--', label=f'Calibrated Mean (b={b:.1%})')\nplt.title(\"Historical Short Rates vs. Calibrated Long-Term Mean\")\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nTo simulate the short rate \\(r_t\\) using the Vasicek model, we can use the following discretized version of the SDE: \\[r_{t+\\Delta t} = r_t + a(b - r_t)\\Delta t + \\sigma \\sqrt{\\Delta t} Z_t\\]\nwhere \\(Z_t\\) is a standard normal random variable.\n\n\nCode\ndef simulate_vasicek_paths(r0, a, b, sigma, T, dt, n_paths):\n    n_steps = int(T / dt)\n    rates = np.zeros((n_steps + 1, n_paths))\n    rates[0] = r0\n    \n    for t in range(1, n_steps + 1):\n        # dz ~ N(0, sqrt(dt))\n        dz = np.random.normal(0, np.sqrt(dt), n_paths)\n        # dr = a(b - r)dt + sigma * dW\n        rates[t] = rates[t-1] + a * (b - rates[t-1]) * dt + sigma * dz\n        \n    return rates\n\n\n\n\nCode\n# Simulation parameters\nr0 = rates[-1]\nT = 1.0  # 1 year\ndt = 1/252  # daily steps\nn_paths = 1000  # number of simulated paths\n\nrates_sim = simulate_vasicek_paths(r0, a, b, sigma, T, dt, n_paths)\ntime_grid = np.linspace(0, T, int(T/dt) + 1)\n\nmean_rates = np.mean(rates_sim, axis=1)\nplt.figure(figsize=(10, 6))\nplt.plot(time_grid, rates_sim[:, :50], lw=1) \nplt.plot(time_grid, mean_rates, lw=2, color='blue')\nplt.title('Simulated Interest Rate Paths (Vasicek Model)')\nplt.xlabel('Time (years)')\nplt.ylabel('Interest Rate (%)')\nplt.axhline(y=b, color='r', linestyle='--', label='Long-term Mean (b)')\nplt.text(0.1, b - 0.003, f'b = {b:.4f}', color='r')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\nC:\\Users\\mengh\\AppData\\Local\\Temp\\ipykernel_2312\\3343935822.py:2: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  r0 = rates[-1]\n\n\n\n\n\n\n\n\n\n\n\n\nThe price of a zero-coupon bond in the Vasicek model can be calculated using the following formula: \\[P(t,T) = A(t,T) e^{-B(t,T) r_t}\\] where: - \\(P(t,T)\\) is the price of the bond at time \\(t\\) maturing at time \\(T\\), - \\(A(t,T)\\) and \\(B(t,T)\\) are functions defined as:\n\\[B(t,T) = \\dfrac{1 - e^{-a(T-t)}}{a}\\]\n\\[A(t,T) = \\exp\\left( \\left( b - \\dfrac{\\sigma^2}{2a^2} \\right) \\left( B(t,T) - (T-t) \\right) - \\dfrac{\\sigma^2 B(t,T)^2}{4a} \\right)\\]\n\n\nCode\ndef analytical_bond_price(r, a, b, sigma, T):\n    B = (1 - np.exp(-a * T)) / a\n    A = np.exp((B - T) * (a**2 * b - 0.5 * sigma**2) / a**2 - (sigma**2 * B**2) / (4 * a))\n    P = A * np.exp(-B * r)\n    return P\n\nT_bond = 1.0  # 1 year bond\nbond_prices = analytical_bond_price(r0, a, b, sigma, T_bond)\nprint(f\"Analytical price of a zero-coupon bond maturing in {T_bond} year(s): {bond_prices:.4f}\")\n\n\nAnalytical price of a zero-coupon bond maturing in 1.0 year(s): 0.9617\n\n\n\n\n\nTo estimate the price of a Zero-Coupon Bond (ZCB) using Monte Carlo simulation, we can follow these steps:\nThe price of a bond is the risk-neutral expectation of the discounted payoff:\n\\[P(0,T) = E^Q\\left[e^{-\\int_0^T r_t dt}\\right]\\]\nIn our simulation, the integral becomes a sum, and the expectation is approximated by the average over many simulated paths.\n\\[P_{MC} \\approx \\dfrac{1}{N} \\sum_{i=1}^{N}\\left( \\exp \\left(-\\sum_{j=0}^{M-1} r_{t_j}^{(i)} \\Delta t \\right)\\right)\\]\n\n\nCode\ndef price_bond_mc(rates, dt):\n    # Stochastic Discount Factor: exp(-integral of r_t dt)\n    integral_r = np.sum(rates[:-1, :], axis=0) * dt\n    payoffs = np.exp(-integral_r)\n    return np.mean(payoffs)\n\n# Price a 1-year bond\nT_target = 1.0\nsteps_target = int(T_target / dt)\nmc_price = price_bond_mc(rates_sim[:, :], dt)\nanalyt_price = analytical_bond_price(r0, a, b, sigma, T_target)\n\nprint(f\"--- Comparison  ---\")\nprint(f\"Analytical Price (1Y): {analyt_price:.5f}\")\nprint(f\"Monte Carlo Price (1Y): {mc_price:.5f}\")\nprint(f\"Error: {abs(mc_price - analyt_price):.5f}\")\n\n\n--- Comparison  ---\nAnalytical Price (1Y): 0.96173\nMonte Carlo Price (1Y): 0.96175\nError: 0.00001\n\n\n\n\n\n\n\nCode\n# Parameters\nT_max = 10\ndt = 1/252\n\n\nmaturities = np.arange(1,T_max+1)\nanalytical_prices = [analytical_bond_price(r0, a, b, sigma, T) for T in maturities]\n\n# Monte Carlo\nn_paths = 1000\nmc_prices = []\nfor T in maturities:\n    full_paths = simulate_vasicek_paths(r0, a, b, sigma, T, dt, n_paths)\n    integral_r = np.sum(full_paths, axis=0)*dt\n    mc_prices.append(np.mean(np.exp(-integral_r)))\n\nplt.figure(figsize=(10, 5))\nplt.plot(maturities, analytical_prices, 'o-', label='Analytical Price', markersize=8)\nplt.plot(maturities, mc_prices, 'x--', label=f'Monte Carlo Price (N={n_paths})', markersize=8)\nplt.title(\"Task 3: Analytical vs. Monte Carlo Bond Prices\")\nplt.xlabel(\"Maturity (Years)\")\nplt.ylabel(\"Price\")\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\nabsolute_errors = [abs(ap - mp) for ap, mp in zip(analytical_prices, mc_prices)]\n\ncomparison_df = pd.DataFrame({\n    'Maturity (Years)': maturities,\n    'Analytical Price': analytical_prices,\n    f'Monte Carlo Price (N={n_paths})': mc_prices,\n    'Absolute Error': absolute_errors\n})\n\ncomparison_df\n\n\n\n\n\n\n\n\n\nMaturity (Years)\nAnalytical Price\nMonte Carlo Price (N=1000)\nAbsolute Error\n\n\n\n\n0\n1\n0.961734\n0.961529\n0.000205\n\n\n1\n2\n0.927366\n0.927190\n0.000176\n\n\n2\n3\n0.896006\n0.895275\n0.000731\n\n\n3\n4\n0.867007\n0.865980\n0.001027\n\n\n4\n5\n0.839894\n0.839199\n0.000695\n\n\n5\n6\n0.814320\n0.814280\n0.000040\n\n\n6\n7\n0.790027\n0.790127\n0.000099\n\n\n7\n8\n0.766825\n0.769030\n0.002205\n\n\n8\n9\n0.744570\n0.743563\n0.001008\n\n\n9\n10\n0.723155\n0.719999\n0.003156\n\n\n\n\n\n\n\n\n\n\nUsing the analytical bond pricing formula, generate the yield curve for different maturities $ T $ by calculating the yield $ y(0,T) $: \\[ y(0,T) = -\\frac{1}{T} \\ln(P(0,T)) \\]\n\nAnalyze how changes in parameters $ a $, $ b $, and $ $ affect the shape of the yield curve.\n\n\n\nCode\nmaturities = np.linspace(0.1, 10, 100)\n\ndef get_yields(a, b, sigma):\n    prices = [analytical_bond_price(r0, a, b, sigma, T) for T in maturities]\n    return -np.log(prices) / maturities\n\n\n\n\nCode\nplt.figure(figsize=(12, 8))\nplt.plot(maturities, get_yields(a, b, sigma), label='Base Case', lw=2)\nplt.title(\"Base Yield Curve\")\nplt.xlabel(\"Maturity\")\nplt.ylabel(\"Yield\")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\nplt.figure(figsize=(12, 5))\nplt.subplot(1, 2, 1)\n\na_imp = [a/2, a, a*2]\nfor a_val in a_imp:\n    yields = get_yields(a_val, b, sigma)\n    plt.plot(maturities, yields, label=f'a={a_val:.4f}')\nplt.title(\"Impact of Mean Reversion Speed (a)\")\nplt.xlabel(\"Maturity (Years)\")\nplt.ylabel(\"Yield\")\nplt.legend()\nplt.grid(True)\n\n# Scenario B: Effect of 'sigma' (Volatility)\nsigma_imp = [sigma/2, sigma, sigma*2]\nplt.subplot(1, 2, 2)\nfor sig_val in sigma_imp:\n    yields = get_yields(a, b, sig_val)\n    plt.plot(maturities, yields, label=f'sigma={sig_val:.4f}')\nplt.title(\"Impact of Volatility (sigma)\")\nplt.xlabel(\"Maturity (Years)\")\nplt.ylabel(\"Yield\")\nplt.legend()\nplt.grid(True)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Task 4: Yield Curve and Sensitivity\nm_yields = np.linspace(0.1, 30, 100)\ndef get_yields(a, b, sigma):\n    prices = [analytical_bond_price(r0, a, b, sigma, T) for T in m_yields]\n    return -np.log(prices) / m_yields\n\nplt.figure(figsize=(12, 8))\nplt.subplot(2, 2, 1)\nplt.plot(m_yields, get_yields(a, b, sigma), label='Base Case', lw=2)\nplt.title(\"Base Yield Curve\")\nplt.xlabel(\"Maturity\")\nplt.ylabel(\"Yield\")\nplt.grid(alpha=0.5)\n\nplt.subplot(2, 2, 2)\nplt.plot(m_yields, get_yields(a, b, sigma), label=f'a={a:.2f}')\nplt.plot(m_yields, get_yields(2*a, b, sigma), label=f'a={2*a:.2f}')\nplt.title(\"Sensitivity to Mean Reversion (a)\")\nplt.legend()\nplt.grid(alpha=0.5)\n\nplt.subplot(2, 2, 3)\nplt.plot(m_yields, get_yields(a, b, sigma), label=f'b={b:.2f}')\nplt.plot(m_yields, get_yields(a, 2*b, sigma), label=f'b={2*b:.2f}')\nplt.title(\"Sensitivity to Long-term Mean (b)\")\nplt.legend()\nplt.grid(alpha=0.5)\n\nplt.subplot(2, 2, 4)\nplt.plot(m_yields, get_yields(a, b, sigma), label=f'$\\sigma={sigma:.2f}$')\nplt.plot(m_yields, get_yields(a, b, 2*sigma), label=f'$\\sigma={2*sigma:.2f}$')\nplt.title(\"Sensitivity to Volatility ($\\sigma$)\")\nplt.legend()\nplt.grid(alpha=0.5)\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "cir_model.html",
    "href": "cir_model.html",
    "title": "The CIR Stochastic Differential Equation (SDE)",
    "section": "",
    "text": "\\[dr_t = a(b-r_t)dt + \\sigma \\sqrt{r_t}dW_t\\] Where: - $ r_t $ is the interest rate at time ( t ) - $ a $ is the speed of mean reversion - $ b $ is the long-term mean level of the interest rate - $ $ is the volatility of the interest rate - $ W_t $ is a standard Wiener process (Brownian motion) ### Key Properties of the CIR Model 1. Mean Reversion: The term $ a(b - r_t) $ ensures that the interest rate tends to revert to the long-term mean $ b $ over time. 2. Non-Negativity: The square root term $ $ ensures that the interest rate remains non-negative, provided that the Feller condition $ 2ab ^2 $ is satisfied. 3. Volatility Structure: The volatility of the interest rate is proportional to the square root of the current rate, meaning that volatility decreases as the interest rate approaches zero. ### Applications of the CIR Model - Interest Rate Modeling: The CIR model is widely used to model the evolution of interest rates over time in financial markets. - Bond Pricing: It is used to price interest rate derivatives and bonds, particularly those with embedded options. - Risk Management: The model helps in assessing the risk associated with interest rate movements for financial institutions. ### Solution to the CIR SDE The CIR model has a known closed-form solution for the transition density of $ r_t $. The distribution of $ r_t $ given $ r_0 $ is a non-central chi-squared distribution. Specifically, if $ r_0 $ is the initial interest rate, then: \\[ r_t \\sim \\frac{\\sigma^2(1 - e^{-at})}{4a} \\chi^2_{d}(\\lambda) \\] Where: - $ d = $ is the degrees of freedom - $ = $ is the non-centrality parameter ### Parameter Estimation Parameters $ a $, $ b $, and $ $ can be estimated using historical interest rate data through methods such as Maximum Likelihood Estimation (MLE) or the Generalized Method of Moments (GMM). ### Numerical Simulation of the CIR Model To simulate paths of the CIR model, one can use the Euler-Maruyama method or more advanced techniques like the Milstein scheme. A simple Euler discretization is given by: \\[ r_{t+\\Delta t} = r_t + a(b - r_t)\\Delta t + \\sigma \\sqrt{r_t} \\sqrt{\\Delta t} Z \\] Where $ Z $ is a standard normal random variable.\n\nTask 2: Simulation and Monte Carlo Pricing\n\nDiscretize the SDE using the Euler-Maruyama method.\n\nInterval \\([0,T]\\) : step size \\(\\Delta t = \\frac{T}{N}\\), where \\(N\\) is the number of time steps.\n\nFor the CIR model, the discretized form is: \\[ r_{t+\\Delta t} = r_t + a(b - r_t)\\Delta t + \\sigma \\sqrt{r_t} \\sqrt{\\Delta t} Z \\] Where $ Z N(0,1) $ is a standard normal random variable.\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef simulate_cir_paths(r0, a, b, sigma, T, dt, n_paths):\n    n_steps = int(T / dt)\n    rates = np.zeros((n_steps + 1, n_paths))\n    rates[0] = r0\n    \n    for t in range(1, n_steps + 1):\n        # Standard Normal Random Variables\n        dz = np.random.normal(0, np.sqrt(dt), n_paths)\n        \n        # CIR SDE: dr = a(b - r)dt + sigma * sqrt(r) * dW\n        # We use np.maximum to ensure r doesn't go negative in the sqrt\n        previous_r = rates[t-1]\n        drift = a * (b - previous_r) * dt\n        diffusion = sigma * np.sqrt(np.maximum(previous_r, 0)) * dz\n        rates[t] = previous_r + drift + diffusion\n        \n    return rates\n\n\n\nCalculate the bond price at maturity \\(T\\) using the simulated interest rate paths.\nThe price of a zero-coupon bond at time \\(t\\) maturing at time \\(T\\) is given by: \\[ P(t,T) = E_t\\left[e^{-\\int_t^T r_s ds}\\right] \\]\nUsing Monte Carlo simulation, we can approximate this expectation by averaging over multiple simulated paths of the interest rate.\nEstimate the bond price using Monte Carlo simulation.\n\nSimulate multiple paths of the interest rate \\(r_t\\) using the discretized CIR model.\nFor each path, compute the integral \\(\\int_0^T r_s ds\\) using numerical integration (e.g., trapezoidal rule).\nCalculate the bond price for each path and average the results to get the estimated bond price: \\[ \\hat{P}(0,T) = \\frac{1}{M} \\sum_{i=1}^{M} e^{-\\int_0^T r_s^{(i)} ds} \\] Where \\(M\\) is the number of simulated paths and \\(r_s^{(i)}\\) is the interest rate path for the \\(i\\)-th simulation.\n\nCalculate the Bond Price\n\nFor each simulated path \\(i\\), calculate the “Stochastic Discount Factor” (SDF): \\[ D_i = \\exp \\left(-\\sum_{j=1}^{M} r_j \\Delta t \\right) \\]\nThe Monte Carlo price is the average of these factors across all \\(N\\) paths:\n\n\\[ P_{MC}(0,T) \\approx \\frac{1}{N} \\sum_{i=1}^{N} D_i \\]\n\n\n\nCode\ndef price_bond_mc(rates, dt):\n    # Integral of r_t dt using the trapezoidal rule or simple sum\n    integral_r = np.sum(rates[:-1], axis=0) * dt\n    # Average of the discount factors\n    return np.mean(np.exp(-integral_r))\n\n\n\n\nCode\n# Parameters\na = 0.2\nb = 0.05\nsigma = 0.03\nr0 = 0.03\nT_max = 10\ndt = 1/252\nn_steps = int(T_max / dt)\ntime_grid = np.linspace(0, T_max, n_steps + 1)\nn_paths = 100\npaths = simulate_cir_paths(r0, a, b, sigma, T, dt, n_paths)\nmc_price = price_bond_mc(paths, dt)\n\nprint(f\"Monte Carlo Bond Price (5Y): {mc_price:.4f}\")\n\n\nMonte Carlo Bond Price (5Y): 0.8288\n\n\n\n\nCode\nnp.random.seed(42)\npaths = simulate_cir_paths(r0, a, b, sigma, T_max, dt, n_paths)\nmean_rates = np.mean(paths, axis=1)\nplt.figure(figsize=(10, 6))\nplt.plot(time_grid, paths ,alpha=0.5)\nplt.plot(time_grid, mean_rates, label='Mean Short Rate', color='blue')\nplt.axhline(y=b, color='r', linestyle='--', label=f'Long-term Mean (b={b})')\nplt.title(\"Simulated Short Rate Paths (CIR Model)\")\nplt.xlabel(\"Time (Years)\")\nplt.ylabel(\"Interest Rate ($r_t$)\")\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\n## Calculate the mean of interest rates at each time step\nmean_rates = np.mean(paths, axis=1)\nplt.figure(figsize=(10, 6))\nplt.plot(time_grid, mean_rates, label='Mean Short Rate', color='blue')\nplt.axhline(y=b, color='r', linestyle='--', label=f'Long-term Mean (b={b})')\nplt.title(\"Mean Short Rate Over Time (CIR Model)\")\nplt.xlabel(\"Time (Years)\")\nplt.ylabel(\"Mean Interest Rate ($r_t$)\")\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nTask 3: Analytical Bond Pricing\n\nThe analytical bond price in the CIR model is given by: \\[ P(0,T) = A(T) e^{-B(T) r_0} \\] Where:\nWe define a constant \\(\\gamma = \\sqrt{a^2 + 2\\sigma^2}\\)\n\\[ A(T) = \\left( \\dfrac{2\\gamma e^{(a+\\gamma)T/2}}{(a+\\gamma)(e^{\\gamma T}-1) + 2\\gamma} \\right)^{\\frac{2ab}{\\sigma^2}} \\]\n\\[ B(T) = \\dfrac{2(e^{\\gamma T}-1)}{(a+\\gamma)(e^{\\gamma T}-1) + 2\\gamma} \\]\n\n\n\nCode\ndef cir_analytical_price(r0, a, b, sigma, T):\n    if T == 0: return 1.0\n    gamma = np.sqrt(a**2 + 2 * sigma**2)\n    exp_g = np.exp(gamma * T)\n    # calculate B(T)\n    den_b = (gamma + a) * (exp_g - 1) + 2 * gamma\n    B = 2 * (exp_g - 1) / den_b\n    # calculate A(T)\n    num_a = 2 * gamma * np.exp((a + gamma) * T / 2)\n    A = (num_a / den_b)**(2 * a * b / sigma**2)\n\n    return A * np.exp(-B * r0)\n\n\n\n\nCode\n# Validation\nmc_price = price_bond_mc(paths[:, :n_paths], dt)\nanalytical_price = cir_analytical_price(r0, a, b, sigma, T_max)\nerror = abs(mc_price - analytical_price)\n\nprint(f\"Monte Carlo Price: {mc_price:.4f}\")\nprint(f\"Analytical Price: {analytical_price:.4f}\")\nprint(f\"Absolute Error: {error:.4f}\")\n\n\nMonte Carlo Price: 0.6608\nAnalytical Price: 0.6624\nAbsolute Error: 0.0016\n\n\nComparison of Monte Carlo and Analytical Prices\n\n\nCode\n# Task 3: Compare Analytical vs Simulated Prices\n\n# Parameters\na_base = 0.2\nb_base = 0.05\nsigma_base = 0.03\nr0 = 0.03\nT_max = 10\ndt = 1/252\nn_steps = int(T_max / dt)\ntime_grid = np.linspace(0, T_max, n_steps + 1)\nn_paths = 100\n\nmaturities = np.arange(1, 11)\nanalytical_prices = [cir_analytical_price(r0, a_base, b_base, sigma_base, T) for T in maturities]\n\n# Monte Carlo with N=500\nn_paths_mc = 500\nfull_paths = simulate_cir_paths(r0, a_base, b_base, sigma_base, 10, dt, n_paths_mc)\nmc_prices = []\nfor T in maturities:\n    steps_T = int(T / dt)\n    integral_r = np.sum(full_paths[:steps_T, :], axis=0) * dt\n    mc_prices.append(np.mean(np.exp(-integral_r)))\n\nplt.figure(figsize=(10, 5))\nplt.plot(maturities, analytical_prices, 'o-', label='Analytical Price', markersize=8)\nplt.plot(maturities, mc_prices, 'x--', label=f'Monte Carlo Price (N={n_paths_mc})', markersize=8)\nplt.title(\"Task 3: Analytical vs. Monte Carlo Bond Prices\")\nplt.xlabel(\"Maturity (Years)\")\nplt.ylabel(\"Price\")\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\nThis plot compares the Zero-Coupon Bond prices calculated using the exact mathematical formula (Analytical) against the average of \\(500\\) simulated paths (Monte Carlo).\n\nObservations: The Monte Carlo prices (marked with ‘x’) align almost perfectly with the analytical prices (the solid line). This confirms that your simulation logic is correct.\nTrend: As maturity increases, the bond price decreases. This is intuitive, as a dollar received 10 years from now is worth less today than a dollar received 1 year from now.\n\n\n\nCode\n# Camparision dataframe\nimport pandas as pd\n\nabsolute_errors = [abs(ap - mp) for ap, mp in zip(analytical_prices, mc_prices)]\n\ncomparison_df = pd.DataFrame({\n    'Maturity (Years)': maturities,\n    'Analytical Price': analytical_prices,\n    f'Monte Carlo Price (N={n_paths_mc})': mc_prices,\n    'Absolute Error': absolute_errors\n})\n\ncomparison_df\n\n\n\n\n\n\n\n\n\nMaturity (Years)\nAnalytical Price\nMonte Carlo Price (N=500)\nAbsolute Error\n\n\n\n\n0\n1\n0.968633\n0.968707\n0.000074\n\n\n1\n2\n0.935192\n0.935387\n0.000195\n\n\n2\n3\n0.900510\n0.901095\n0.000585\n\n\n3\n4\n0.865241\n0.866004\n0.000763\n\n\n4\n5\n0.829891\n0.830716\n0.000825\n\n\n5\n6\n0.794845\n0.796051\n0.001206\n\n\n6\n7\n0.760391\n0.762064\n0.001673\n\n\n7\n8\n0.726739\n0.728752\n0.002013\n\n\n8\n9\n0.694039\n0.696681\n0.002642\n\n\n9\n10\n0.662392\n0.665510\n0.003118\n\n\n\n\n\n\n\n\n\nTask 4: Yield Curve and Parameter Analysis\n\nYield Curve Generation\n\nUsing the analytical bond pricing formula, generate the yield curve for different maturities $ T $ by calculating the yield $ y(0,T) $: \\[ y(0,T) = -\\frac{1}{T} \\ln(P(0,T)) \\]\n\nParameter Sensitivity Analysis\n\nAnalyze how changes in parameters $ a $, $ b $, and $ $ affect the shape of the yield curve.\nFor example, increase/decrease each parameter by a certain percentage and observe the resulting changes in bond prices and yields.\n\n\n\n\nCode\n# Task 4: Yield Curve and Sensitivity\nm_yields = np.linspace(0.1, 30, 100)\ndef get_yields(a, b, sigma):\n    prices = [cir_analytical_price(r0, a, b, sigma, T) for T in m_yields]\n    return -np.log(prices) / m_yields\n\nplt.figure(figsize=(12, 8))\nplt.subplot(2, 2, 1)\nplt.plot(m_yields, get_yields(a_base, b_base, sigma_base), label='Base Case', lw=2)\nplt.title(\"Base Yield Curve\")\nplt.xlabel(\"Maturity\")\nplt.ylabel(\"Yield\")\n\nplt.subplot(2, 2, 2)\nplt.plot(m_yields, get_yields(a_base, b_base, sigma_base), label='a=0.2')\nplt.plot(m_yields, get_yields(0.8, b_base, sigma_base), label='a=0.8')\nplt.title(\"Sensitivity to Mean Reversion (a)\")\nplt.legend()\n\nplt.subplot(2, 2, 3)\nplt.plot(m_yields, get_yields(a_base, b_base, sigma_base), label='b=0.05')\nplt.plot(m_yields, get_yields(a_base, 0.08, sigma_base), label='b=0.08')\nplt.title(\"Sensitivity to Long-term Mean (b)\")\nplt.legend()\n\nplt.subplot(2, 2, 4)\nplt.plot(m_yields, get_yields(a_base, b_base, sigma_base), label='$\\sigma=0.03$')\nplt.plot(m_yields, get_yields(a_base, b_base, 0.1), label='$\\sigma=0.10$')\nplt.title(\"Sensitivity to Volatility ($\\sigma$)\")\nplt.legend()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\nThis dashboard shows how the term structure of interest rates changes when you manipulate the model’s “knobs” (\\(a, b, \\sigma\\)).\n\nBase Case: A typical upward-sloping yield curve starting at \\(r_0 = 0.03\\) and converging toward the mean.\nSensitivity to \\(a\\) (Speed): A higher \\(a\\) (0.8 vs 0.2) causes the curve to reach the long-term mean much faster, resulting in a steeper initial slope.\nSensitivity to \\(b\\) (Mean): Increasing \\(b\\) shifts the entire “long end” of the curve upward, as the market expects rates to be higher in the distant future.\nSensitivity to \\(\\sigma\\) (Volatility): Higher volatility actually creates a downward pressure on the yield curve for long maturities. This is due to “convexity bias”—as uncertainty increases, the value of the bond’s floor (it can’t go below zero) becomes more valuable, raising the bond price and thus lowering the yield."
  }
]